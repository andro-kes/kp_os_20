# Аллокаторы памяти

Проект реализует два различных алгоритма управления памятью на языке C99:

1. **Segregated Free-List (Сегрегированные списки свободных блоков)** - аллокатор с размерными классами
2. **McKusick-Karels (Упрощенный алгоритм страниц/корзин)** - аллокатор на основе страниц и корзин

## Структура проекта

```
mem-allocators/
├── include/              # Заголовочные файлы
│   ├── allocator.h       # Общий интерфейс аллокатора
│   ├── segregated_freelist.h
│   └── mckusick_karels.h
├── src/                  # Исходные файлы
│   ├── allocator.c       # Реализация общего интерфейса
│   ├── segregated_freelist.c
│   └── mckusick_karels.c
├── tests/                # Модульные тесты
│   └── test_allocators.c
├── bench/                # Бенчмарки
│   └── benchmark.c
├── scripts/              # Скрипты для запуска и визуализации
│   ├── run_benchmarks.sh
│   └── plot_results.py
├── results/              # Результаты бенчмарков (CSV)
│   └── sample_results.csv
├── build/                # Скомпилированные бинарники (создается автоматически)
├── Makefile              # Makefile для сборки
└── README.md             # Этот файл
```

## Описание аллокаторов

### 1. Segregated Free-List (Сегрегированные списки свободных блоков)

**Принцип работы:**
- Память организована в виде нескольких списков свободных блоков
- Каждый список содержит блоки определенного размера (размерный класс)
- Размерные классы: 16, 32, 64, 128, 256, 512, 1024, 2048 байт
- При запросе памяти выбирается подходящий список по размеру
- Быстрое выделение и освобождение памяти благодаря прямому доступу к спискам

**Преимущества:**
- Минимальная фрагментация для популярных размеров
- Быстрое выделение памяти O(1) для размерных классов
- Простая реализация

**Недостатки:**
- Внутренняя фрагментация при несовпадении размеров
- Неэффективен для больших блоков

### 2. McKusick-Karels (Упрощенный алгоритм страниц/корзин)

**Принцип работы:**
- Память организована в виде страниц фиксированного размера (4096 байт)
- Каждая страница разделена на объекты одинакового размера (корзины)
- Используется битовая карта для отслеживания свободных объектов
- Размеры корзин: 16, 32, 64, 128, 256, 512, 1024, 2048 байт

**Преимущества:**
- Эффективное использование памяти для объектов одного размера
- Хорошая локальность данных
- Быстрое освобождение через битовую карту

**Недостатки:**
- Более сложная реализация
- Накладные расходы на управление страницами

## Установка и сборка

### Требования

- GCC компилятор с поддержкой C99
- GNU Make
- Linux/Unix система
- Python 3 (опционально, для визуализации)
- matplotlib, pandas (опционально, для графиков)

### Сборка

```bash
cd mem-allocators
make all
```

Эта команда скомпилирует все модули и создаст два исполняемых файла:
- `build/test_allocators` - модульные тесты
- `build/benchmark` - программа для бенчмарков

### Дополнительные команды Make

```bash
make test              # Сборка и запуск тестов
make bench             # Сборка и запуск всех бенчмарков
make bench-segregated  # Бенчмарки только для Segregated Free-List
make bench-mckusick    # Бенчмарки только для McKusick-Karels
make clean             # Очистка бинарников
make distclean         # Полная очистка (включая результаты)
make help              # Справка по командам
```

## Использование

### API аллокатора

```c
#include "allocator.h"

// Создание аллокатора
allocator_t* alloc = allocator_create(ALLOCATOR_SEGREGATED_FREELIST, 1024*1024);

// Выделение памяти
void* ptr = allocator_alloc(alloc, 256);

// Использование памяти
memset(ptr, 0, 256);

// Освобождение памяти
allocator_free(alloc, ptr);

// Уничтожение аллокатора
allocator_destroy(alloc);
```

### Типы аллокаторов

```c
ALLOCATOR_SEGREGATED_FREELIST  // Сегрегированные списки свободных блоков
ALLOCATOR_MCKUSICK_KARELS      // McKusick-Karels
```

### Запуск тестов

```bash
# Сборка и запуск тестов
make test

# Или напрямую
./build/test_allocators
```

Тесты проверяют:
- Базовое выделение и освобождение памяти
- Множественные выделения
- Различные размеры блоков
- Повторное использование памяти
- Граничные случаи

### Запуск бенчмарков

#### Через скрипт (рекомендуется)

```bash
cd scripts
./run_benchmarks.sh
```

Опции:
- `-n, --num-ops <число>` - количество операций на бенчмарк (по умолчанию: 10000)
- `-h, --help` - справка

#### Напрямую

```bash
# Все аллокаторы
./build/benchmark -o results/results.csv

# Конкретный аллокатор
./build/benchmark -a segregated -o results/segregated.csv
./build/benchmark -a mckusick -o results/mckusick.csv

# С заданным числом операций
./build/benchmark -n 50000 -o results/results.csv
```

Опции командной строки:
- `-a, --allocator <тип>` - тип аллокатора: segregated, mckusick, all
- `-n, --num-ops <число>` - количество операций
- `-o, --output <файл>` - выходной CSV файл
- `-h, --help` - справка

### Типы бенчмарков

1. **Sequential** - последовательные выделения и освобождения
2. **Random** - случайные выделения и освобождения разных размеров
3. **Mixed** - смешанный паттерн (выделение-освобождение-повторное использование)
4. **Stress** - стресс-тест с большим количеством выделений

### Визуализация результатов

Требуется Python 3 с установленными пакетами matplotlib и pandas:

```bash
pip3 install matplotlib pandas
```

Создание графиков:

```bash
# Один файл результатов
python3 scripts/plot_results.py results/benchmark_results.csv

# Сравнение нескольких файлов
python3 scripts/plot_results.py results/*.csv -c -o comparison.png

# С указанием выходного файла
python3 scripts/plot_results.py results/results.csv -o my_plot.png
```

## Примеры результатов

Примерные результаты бенчмарков (операций в секунду):

| Аллокатор             | Sequential | Random    | Mixed     | Stress    |
|-----------------------|------------|-----------|-----------|-----------|
| SegregatedFreeList    | 398,634    | 218,944   | 223,964   | 294,568   |
| McKusickKarels        | 328,157    | 191,056   | 178,034   | 253,413   |

*Примечание: Результаты зависят от конфигурации системы и параметров бенчмарков.*

## Анализ производительности

### Segregated Free-List
- **Лучше для**: частых выделений/освобождений малых блоков
- **Быстрее на**: последовательных операциях
- **Преимущество**: простота и предсказуемость

### McKusick-Karels
- **Лучше для**: множества объектов одного размера
- **Быстрее на**: операциях с хорошей локальностью
- **Преимущество**: эффективное использование памяти

## Разработка

### Добавление новых тестов

Редактируйте `tests/test_allocators.c`:

```c
void test_my_feature(allocator_type_t type, const char* name) {
    TEST(name);
    // Ваш тест здесь
    TEST_PASS();
}

// В main():
test_my_feature(ALLOCATOR_SEGREGATED_FREELIST, "My Test");
```

### Добавление новых бенчмарков

Редактируйте `bench/benchmark.c`:

```c
void benchmark_my_scenario(allocator_t* alloc, const char* alloc_name, 
                           size_t num_ops, FILE* output) {
    double start = get_time_us();
    // Ваш бенчмарк
    double end = get_time_us();
    // Вывод результатов
}
```

## Устранение проблем

### Ошибки компиляции

```bash
# Проверьте версию GCC
gcc --version

# Должна поддерживать C99
gcc -std=c99 -v
```

### Ошибки выполнения

- **Segmentation fault**: проверьте размер кучи при создании аллокатора
- **Failed allocations**: увеличьте размер кучи или уменьшите количество операций
- **Invalid pointer errors**: убедитесь, что освобождаете только выделенную память

### Проблемы с производительностью

- Используйте опцию `-O2` или `-O3` при компиляции
- Увеличьте размер кучи для больших нагрузок
- Проверьте, что система не перегружена другими процессами

## Лицензия

Этот проект создан в образовательных целях.

## Авторы

Проект разработан как курсовая работа по операционным системам.

## Дополнительная информация

### Ссылки

- [Описание Segregated Free Lists](https://en.wikipedia.org/wiki/Free_list)
- [McKusick-Karels Allocator (BSD malloc)](https://docs.freebsd.org/44doc/psd/28.malloc/paper.pdf)
- [Memory Allocation Strategies](https://www.cs.princeton.edu/courses/archive/fall16/cos316/lectures/13-allocation.pdf)

### Контакты

Для вопросов и предложений создавайте issue в репозитории проекта.
